{-
  TASK 5 - Fibonacci sequence
  Implement a function that generates the Fibonacci
  sequence from N to N+K terms (0<=N<=370; 0<=N+K<=371; 0<=K<=255).
  The first two terms of the Fibonacci sequence are F_0 = 0 and F_1 = 1,
  and the rest are defined as F_n = F_(n-1) + F_(n-2).
  The resulting Fibonacci sequence should be stored in a tuple.
  For example, a request with N = 1 and K = 3 should return a tuple [1, 1, 2],
  and a request with N = 201 and K = 4 should return a tuple
  [453973694165307953197296969697410619233826,
  734544867157818093234908902110449296423351,
  1188518561323126046432205871807859915657177,
  1923063428480944139667114773918309212080528]
-}

() recv_internal() {
}

(int) tlen (tuple t) asm "TLEN";
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple) nop(X x) asm "NOP";

;; testable
(tuple) mmlt(tuple matrixA, tuple matrixB) method_id {
	tuple matrixC = empty_tuple();
	int n = matrixA.tlen();
	int m = matrixB.tlen();
	int p = matrixB.at(0).tlen();
	int i = 0;

	while (i < n) {
		tuple temp = empty_tuple();
		int j = 0;

		while (j < p) {
			int sum = 0;

			int k = 0;
			while (k < m) {
				sum = sum + (matrixA.at(i).at(k) * matrixB.at(k).at(j));
				k = k + 1;
			}

			temp~tpush(sum);
			j = j + 1;
		}

		matrixC~tpush(temp);
		i = i + 1;
	}

	return matrixC;
}

(tuple) mexp(tuple base, int n) {
  tuple res = nop([[1, 0], [0, 1]]);
  while (n > 0) {
      if (n % 2 == 1) {
        res = mmlt(res, base);
      }

      base = mmlt(base, base);
      n /= 2;
  }

  return res;
}

;; testable
(tuple) fibonacci_sequence (int n, int k) method_id {
  tuple base = nop([[1, 1], [1, 0]]);
  tuple result = mexp(base, n - 1);
  tuple out = null();

  int a = result.at(1).at(0);
  int b = result.at(0).at(0);
  out~tpush(out);

  repeat (k - 1) {
    int c = a + b;
    a = b;
    b = c;

    out~tpush(b);
  }

  return out;
}

